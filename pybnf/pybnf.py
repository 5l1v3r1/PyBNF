"""pybnf.pybnf: defines the entry point for the PyBNF application"""

import logging
import logging.config
import logging.handlers
import argparse
from .parse import load_config
from .config import Configuration, init_logging
import pybnf.printing as printing
from .printing import print0, print1, PybnfError
from .cluster import get_scheduler, setup_cluster, teardown_cluster
import pybnf.algorithms as algs
import os
import shutil
import traceback


__version__ = "0.1"


def main():
    success = False
    node_string = None
    alg = None

    if os.path.isfile('bnf_debug.log'):
        os.remove('bnf_debug.log')
    if os.path.isfile('bnf_errors.log'):
        os.remove('bnf_errors.log')

    try:
        init_logging()

        print0("PyBNF v%s" % __version__)
        logging.info('Running PyBNF v%s' % __version__)

        parser = argparse.ArgumentParser(description='Performs parameter fitting on models defined in BNGL')

        parser.add_argument('-c', action='store', dest='conf_file',
                            help='Path to the BioNetFit configuration file', metavar='config.conf')
        parser.add_argument('-o', '--overwrite', action='store_true',
                            help='automatically overwrites existing folders if necessary')
        parser.add_argument('-t', '--cluster_type', action='store',
                            help='optional string denoting the type of cluster')

        # Load the conf file and create the algorithm
        results = parser.parse_args()
        if results.conf_file is None:
            print0('No configuration file given, so I won''t do anything.\nFor more information, try pybnf --help')
            exit(0)
        logging.info('Loading configuration file: %s' % results.conf_file)

        config = load_config(results.conf_file)
        if 'verbosity' in config.config:
            printing.verbosity = config.config['verbosity']
        if results.scheduler_address is not None:
            config.config['scheduler_address'] = results.scheduler_addres

        # Create output folders, checking for overwrites.
        init_output_directory(results.conf_file, config)

        if config.config['fit_type'] == 'pso':
            alg = algs.ParticleSwarm(config)
        elif config.config['fit_type'] == 'de':
            alg = algs.DifferentialEvolution(config)
        elif config.config['fit_type'] == 'ss':
            alg = algs.ScatterSearch(config)
        elif config.config['fit_type'] == 'bmc' or config.config['fit_type'] == 'pt':
            # Note: bmc vs pt difference is handled in Config by setting or not setting the exchange_every key.
            alg = algs.BayesAlgorithm(config)
        elif config.config['fit_type'] == 'sa':
            alg = algs.BayesAlgorithm(config, sa=True)
        elif config.config['fit_type'] == 'sim':
            alg = algs.SimplexAlgorithm(config)
        else:
            raise PybnfError('Invalid fit_type %s. Options are: pso, de, ss, bmc, pt, sa, sim' % config.config['fit_type'])

        # override cluster type value in configuration file if specified with cmdline args
        if results.cluster_type:
            config.config['cluster_type'] = results.cluster_type

        # Set up cluster
        if config.config['scheduler_node'] and config.config['worker_nodes']:
            scheduler_node = config.config['scheduler_node']
            node_string = ' '.join(config.config['worker_nodes'])
        elif config.config['scheduler_node']:
            dummy, node_string = get_scheduler(config)
            scheduler_node = config.config['scheduler_node']
        else:
            scheduler_node, node_string = get_scheduler(config)

        if node_string:
            dask_ssh_proc = setup_cluster(node_string)

        # Run the algorithm!
        logging.debug('Algorithm initialization')
        alg.run(scheduler_node)

        if config.config['refine'] == 1:
            logging.debug('Refinement requested for best fit parameter set')
            if config.config['fit_type'] == 'sim':
                logging.debug('Cannot refine further if Simplex algorithm was used for original fit')
                print1("You specified refine=1, but refine uses the Simplex algorithm, which you already just ran."
                      "\nSkipping refine.")
            else:
                logging.debug('Refining further using the Simplex algorithm')
                print1("Refining the best fit by the Simplex algorithm")
                config.config['simplex_start_point'] = alg.trajectory.best_fit()
                simplex = algs.SimplexAlgorithm(config)
                simplex.trajectory = alg.trajectory  # Reuse existing trajectory; don't start a new one.
                simplex.run(scheduler_node)
        print0('Fitting complete')
        success = True

    except PybnfError as e:
        # Exceptions generated by problems such as bad user input should be caught here and print a useful message
        # before quitting
        logging.error('Terminating due to a PybnfError:')
        logging.error(e.log_message)
        print0('Error: %s' % e.message)
    except KeyboardInterrupt:
        print0('Fitting aborted.')
        logging.info('Terminating due to keyboard interrupt')
        logging.exception('Keyboard interrupt')
    except Exception:
        # Sends any unhandled errors to log instead of to user output
        logging.exception('Internal error')
        exceptiondata = traceback.format_exc().splitlines()
        print0('Sorry, an unknown error occurred: %s\n'
               'Details have been saved to bnf_errors.log.\n'
               'Please report this bug to help us improve PyBNF.' % exceptiondata[-1])
    finally:
        # Stop dask-ssh regardless of success
        if node_string:
            teardown_cluster(dask_ssh_proc)

        # After any error, try to clean up.
        try:
            if not success:
                logging.info('Fitting unsuccessful.  Attempting cleanup')
                if alg:
                    alg.cleanup()
                    logging.info('Completed cleanup after exception')
        except:
            logging.exception('During cleanup, another exception occurred')
        finally:
            exit(1)


def init_output_directory(conf_file, config):
    """
    Creates (or overwrites) output directories for a fitting run

    :param conf_file: The fitting run's configuration file
    :type conf_file: str
    :param config: The current fitting run's configuration
    :type config: Configuration
    :return:
    """
    if os.path.exists(config.config['output_dir']):
        if os.path.isdir(config.config['output_dir']):
            if os.path.exists(config.config['output_dir'] + '/Results') or os.path.exists(
                            config.config['output_dir'] + '/Simulations') or os.path.exists(
                        config.config['output_dir'] + '/Initialize'):
                logging.info("Output directory has subdirectories... querying user for overwrite permission")
                ans = 'x'
                while ans.lower() not in ['y', 'yes', 'n', 'no', '']:
                    ans = input('It looks like your output_dir already contains Results/, Simulations/, and/or '
                                'Initialize/ folders from a previous run. \n'
                                'Overwrite them with the current run? [y/n] (n) ')
                if ans.lower() == 'y' or ans.lower() == 'yes':
                    logging.info("Overwriting existing output directory")
                    if os.path.exists(config.config['output_dir'] + '/Results'):
                        shutil.rmtree(config.config['output_dir'] + '/Results')
                    if os.path.exists(config.config['output_dir'] + '/Simulations'):
                        shutil.rmtree(config.config['output_dir'] + '/Simulations')
                    if os.path.exists(config.config['output_dir'] + '/Initialize'):
                        shutil.rmtree(config.config['output_dir'] + '/Initialize')
                else:
                    logging.info("Output directory has subdirectories... querying user for overwrite permission")
                    ans = 'x'
                    while ans.lower() not in ['y', 'yes', 'n', 'no', '']:
                        ans = input('It looks like your output_dir already contains Results/, Simulations/, and/or '
                                    'Initialize/ folders from a previous run. \n'
                                    'Overwrite them with the current run? [y/n] (n) ')
                    if ans.lower() == 'y' or ans.lower() == 'yes':
                        logging.info("Overwriting existing output directory")
                        if os.path.exists(config.config['output_dir'] + '/Results'):
                            shutil.rmtree(config.config['output_dir'] + '/Results')
                        if os.path.exists(config.config['output_dir'] + '/Simulations'):
                            shutil.rmtree(config.config['output_dir'] + '/Simulations')
                        if os.path.exists(config.config['output_dir'] + '/Initialize'):
                            shutil.rmtree(config.config['output_dir'] + '/Initialize')
                    else:
                        logging.info("Overwrite rejected... exiting")
                        print('Quitting')
                        exit()

    os.makedirs(config.config['output_dir'] + '/Results')
    os.mkdir(config.config['output_dir'] + '/Simulations')
    shutil.copy(conf_file, config.config['output_dir'] + '/Results')

